# Instalación de Elastic Stack en Kubernetes

Elastic Stack  preparado para funcionar en un clúster de kubernetes con deployments realizados desde kubectl y helm.


# Prerequisitos

Antes de todo, obviar la instalación de **Docker**, además,  se debe contar con **HELM** y un clúster k8s en ejecución, con **kube-states-metrics** y  CIDR configurado, en este caso,  se utiliza  el comando **kubeadm init** con los parámetros **`$kubeadm init ---pod-network-cidr=10.244.0.0/16`** (aquél cidr es el requerido por el CNI **kube-flannel**). Considerar además, los siguientes puntos:

 1. Tener activo los **bridges** en iptable (en caso que el comando  **kubeadm join**  en algún nodo, lo reclame)
	 - Modificar: `$vi /usr/lib/sysctl.d/00-system.conf`
	 - añadiendo al final del archivo:
	 - `net.bridge.bridge-nf-call-ip6tables = 1`
	 - `net.bridge.bridge-nf-call-iptables = 1`
	 - `net.bridge.bridge-nf-call-arptables = 1`
	 - Luego ejecutar: `$sysctl --system`
2. Configurar  DNS 
	 - Esto se realiza aplicando un CNI, en este caso utilizamos **flannel** : `kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/k8s-manifests/kube-flannel-legacy.yml` 
3. Verificar funcionamiento DNS (se puede realizar fácilmente utilizando una imagen de **dnstools**)
	1. en **master-node** ejecutar:  `$kubectl run -it --restart=Never --image=infoblox/dnstools:latest dnstools`
	2. dentro del pods en modo bash, verificar dns con el comando dig: `$dig google.com`
	3. con lo anterior se debería obtener respuesta por medio del servicio/ip dns **flannel** y no retornar algo similar a esto: `;;reply from unexpected source: 10.44.0.2#53, expected 10.96.0.10#53`
4. Desplegar **kube-states-metrics**: `kubectl apply -f kube-states-metrics/`
5. Tener instalado el gestor de aplicaciones k8s  **HELM** 
6. Contar con repositorio **elastic** para acceder con **helm**: `helm repo add elastic https://helm.elastic.co`
 

## Deployment de ELASTICSEARCH

Desplegar elasticsearch con las configuraciones del archivo **local-path.yaml** y  **elasticsearch-values.yml**

 1. Ejecutar: `kubectl apply -f elasticsearch/local-path.yaml` . **local-path.yaml** prepara un **storage class**, para que elasticsearch pueda crear un almacenamiento local para su uso, además  habilita los permisos necesarios de lectura/escritura/ejecución. 
 2. ~~En segundo lugar, desplegar elasticsearch con HELM~~ (**este paso lo omitimos, ya que los valores de configuración, están acorde a elasticsearch con seguridad ssl**):  ~~`helm install elasticsearch elastic/elasticsearch -f elasticsearch/elasticsearch-values.yaml --version 7.8.1 --set replicas=1`~~

## Desplegar ELASTICSEARCH con SEGURIDAD habilitada

Para poder utilizar credenciales de acceso, por ejemplo, para kibana, es necesario habilitar la seguridad **xpack** de elasticsearch (**SSL**). Para ello se cuenta con un archivo make (**makefile**), que se encarga de crear las credenciales y certificados para almacenar en los k8s **secrets** .

**PRECAUCIÓN**: Si el usuario que utiliza **docker** ejecuta los comandos con **sudo**, las instrucciones de **makefile** van a generar problemas de permisos, para evitar esto, debe asignar el usuario actual al grupo docker: `$sudo usermod -a -G docker $USER`

1. Proceder con la creación de certificados y la instalación de elasticsearch con helm. En directorio */elasticsearch* ejecutar: `$make secrets install` 
2. Ahora, basta con generar las credenciales de **elasticsearch** necesarias con el siguiente comando: `kubectl exec -it $(kubectl get pods -n kube-system | grep elasticsearch-master-0 | sed -n 1p | awk '{print $1}') -n kube-system -- bin/elasticsearch-setup-passwords auto -b`. De esta forma, se crean usuarios y contraseñas, esta última es aleatoria.
3. Se van a mostrar en pantalla los usuarios y contraseñas, por lo tanto, crearemos los **k8s secrets** necesarios para los **Beats** que utilizaremos con **ELASTIC STACK**: 
	- `kubectl create secret generic elastic-beats-system -n kube-system --from-literal=password=<contraseña autogenerada> --from-literal=username=beats_system`
	- `kubectl create secret generic elastic-kibana-system -n kube-system --from-literal=password=<contraseña autogenerada> --from-literal=username=kibana_system`
4. Actualizar secrets (elastic-credentials) de acuerdo al usuario elastic y su contraseña  `kubectl create secret generic elastic-credentials -n kube-system  --from-literal=password=<autogenerated-password> --from-literal=username=elastic --dry-run -o yaml | kubectl apply -f -` o bien, ejecutar `kubectl edit secrets elastic-credentials -n kube-system` y modificar el campo "data"
## Desplegar Kibana y Beats

Ahora resta desplegar Kibana y los Beats que utilizaremos:

 1. `helm install kibana elastic/kibana -f kibana/kibana-value.yaml`
 2. **PRECAUCIÓN**: Primero, acceder al **Stack Management** de **Kibana** a través del puerto **32601** con el usuario y contraseña de **elastic** (credencial previamente autogenerada) y crear un User, luego crear y asignar al User, un Role con los permisos requeridos para monitorear con **Filebeat**:
    - (Role) en Cluster privileges, añadir: monitor,manage_index_templates,manage_ilm
    - (Role) en Privileges de la sección Index privileges, añadir: read,write,create_index,view_index_metadata,manage,index
 3. Ahora, crearemos el **k8s secrets**  (con usuario y contraseña previamente creado en **Kibana**) para utilizar en filebeat-value.yaml:  `kubectl create secret generic elastic-filebeat-system -n kube-system --from-literal=password=fbmonitoring --from-literal=username=filebeat`
 4. instalar **Filebeat** con helm: `helm install filebeat elastic/filebeat -f filebeat/filebeat-value.yaml`


## Instalar METRICBEAT para metricas de K8S
 1. `helm install metricbeat elastic/metricbeat --values metricbeat/metricbeat_helm.yaml  -n kube-system`

